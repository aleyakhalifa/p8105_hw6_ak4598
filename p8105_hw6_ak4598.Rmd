---
title: "p8105_hw6_ak4598"
author: "Aleya Khalifa"
date: '`r Sys.Date()`'
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)

set.seed(1)
```

# Problem 2

```{r import_2, include = FALSE}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2022-01-01",
    date_max = "2022-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

## 2.1 Set up regression

```{r}
fit = lm(tmax ~ tmin + prcp, data = weather_df)
```

Create desired output *without* uncertainty analysis

**r^2^**

```{r}
fit %>% 
  broom::glance() %>%
  select(r.squared)
```

log(β1*β1)

```{r}
beta1 = fit %>% 
  broom::tidy() %>%
  filter(term == "tmin") %>%
  select(estimate) %>%
  as.numeric()

beta2 = fit %>% 
  broom::tidy() %>%
  filter(term == "prcp") %>%
  select(estimate) %>%
  as.numeric()

log(abs(beta1) * abs(beta2))
```


## 2.2 Bootstrap

First, create bootstrap function

```{r}
boot_sample = function(df) {
  sample_frac(df, replace = TRUE)
}
```

Then, draw 5,000 bootstrap samples.

```{r}
boot_straps = 
  tibble(strap_number = 1:5000) %>% 
  mutate(
    strap_sample = map(strap_number, \(i) boot_sample(df = weather_df))
  )

boot_straps
```

Run above on the simulated 5,000 samples. For each bootstrap sample, I produce estimates the two estimates above. I then summarize the 2.5 and 97.5 quantiles to show the 95% confidence interval.

**r^2^**

```{r}
bootstrap_results = 
  boot_straps %>% 
  mutate(
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df) ),
    results = map(models, broom::glance)) %>% 
  select(-strap_sample, -models) %>% 
  unnest(results) 

bootstrap_results %>% 
  summarize(lower_r2 = quantile(r.squared, .025),
            upper_r2 = quantile(r.squared, .975)) %>% 
  knitr::kable(digits = 3)
```

The table above shows the 95% confidence interval for the r^2^ term.

log(β1\*β1)

*Note: the log() function returns NaN if the value is negative, so here I use the absolute value of `tmin`*

```{r}
bootstrap_results = 
  boot_straps %>% 
  mutate(
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df) ),
    results = map(models, broom::tidy)) %>% 
  select(-strap_sample, -models) %>% 
  unnest(results) 

bootstrap_results %>% 
  filter(term == "tmin" | term == "prcp") %>%
  select(strap_number, term, estimate) %>%
  pivot_wider(names_from = term, values_from = estimate) %>%
  mutate(log_betas = log(abs(tmin) * abs(prcp))) %>%
  summarize(lower = quantile(log_betas, .025, na.rm = TRUE),
         upper = quantile(log_betas, .975)) %>%
  knitr::kable(digits = 3)
```

The table above shows the 95% confidence interval for the log(β1\*β1) term.

# Problem 3

```{r import_3, include = FALSE}
birthweight = read_csv("data/birthweight.csv") %>%
  janitor::clean_names()
```


